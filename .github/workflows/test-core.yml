name: "Test suite"
# https://securitylab.github.com/research/github-actions-preventing-pwn-requests
on:
  push:
    branches:
      - dev
      - release/*
    paths-ignore:
      - 'docs/**'
      - 'help/**'
  pull_request:
    types: [opened, reopened, synchronize]
    paths-ignore:
      - 'docs/**'
      - 'help/**'
      - 'packaging/**'
      - '.pkgr.yml'

permissions:
  contents: read

jobs:
  all:
    name: Units + Features
    if: github.repository == 'opf/openproject'
    runs-on: runs-on,runner=4cpu-linux-x64,family=c7i-flex+c7a,run-id=${{ github.run_id }}
    timeout-minutes: 40
    services:
      # Label used to access the service container
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: appdb
          POSTGRES_INITDB_ARGS: --no-sync --no-instructions --set fsync=off --set full_page_writes=off
        options: >-
          --health-cmd pg_isready
          --health-interval 2s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    env:
      DOCKER_BUILDKIT: 1
      CI_RETRY_COUNT: 2
      DATABASE_URL: postgres://postgres:postgres@localhost:5432/appdb
      PGUSER: postgres
      PGHOST: localhost
      PGPASSWORD: postgres
    steps:
    - uses: actions/checkout@v4
    - uses: ruby/setup-ruby@v1
      with:
        bundler-cache: true
    - uses: actions/setup-node@v4
      with:
        node-version-file: 'package.json'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json
    - name: Cache ANGULAR
      uses: runs-on/cache@v4
      with:
        path: frontend/.angular/cache
        key: angular-${{ hashFiles('package.json', 'frontend/package-lock.json') }}
        restore-keys: |
          angular-
    - name: Cache TEST RUNTIME
      uses: runs-on/cache@v4
      with:
        path: spec/support/runtime-logs
        key: runtime-logs-${{ github.head_ref || github.ref }}-${{ github.sha }}
        restore-keys: |
          runtime-logs-${{ github.head_ref || github.ref }}-
          runtime-logs-
    - name: Migrate DB
      run: |
        JOBS=$(nproc)
        cp docker/ci/database.yml config/
        time bin/rails db:create db:migrate db:schema:dump zeitwerk:check
        echo 'drop database if exists appdb ; create database appdb' | psql -v ON_ERROR_STOP=1 -d postgres
        cat db/structure.sql | psql -v ON_ERROR_STOP=1 -d appdb
        # create and load schema for test databases "appdb1" to "appdb$JOBS", far faster than using parallel_rspec tasks for that
        for i in $(seq 1 $JOBS); do
          echo 'drop database if exists appdb$i ; create database appdb$i with template appdb owner $PGUSER;' | psql -v ON_ERROR_STOP=1 -d postgres
        done
    - name: Precompile assets
      run: |
        npm install
        DATABASE_URL=nulldb://db time bin/rails openproject:plugins:register_frontend assets:precompile
        cp -rp config/frontend_assets.manifest.json public/assets/frontend_assets.manifest.json
    - name: APIv3 specification (OpenAPI 3.0)
      run:  ./script/api/validate_spec
    - name: Unit tests
      run: |
        echo OK
        # shopt -s extglob
        # time bundle exec turbo_tests --verbose -n $(nproc) --runtime-log spec/support/runtime-logs/turbo_runtime_units.log spec/!(features) modules/**/spec/!(features)
    # - name: Feature tests
    #   env:
    #     CAPYBARA_DOWNLOADED_FILE_DIR: /tmp/ci/downloads
    #     CAPYBARA_AWS_ACCESS_KEY_ID: "${{ secrets.CAPYBARA_AWS_ACCESS_KEY_ID }}"
    #     CAPYBARA_AWS_SECRET_ACCESS_KEY: "${{ secrets.CAPYBARA_AWS_SECRET_ACCESS_KEY }}"
    #   run: bin/ci run-features
    # - name: Save CI image to cache
    #   if: steps.cache_docker.outputs.cache-hit != 'true'
    #   run: mkdir -p cache/docker && docker save openproject/ci:v1 -o cache/docker/image.tar
    # - name: Cleanup
    #   if: ${{ always() }}
    #   run: |
    #     ls -al cache/runtime-logs || true
    #     ls -al cache/ || true
    #     du -sh cache/* || true

# github.head_ref is only availabe in PR context and if it is absent then github.run_id
# is used . And github.run_id is unique for each workflow run. So, this option makes
# sure that there is only one build running for a pull request and the build is attached
# to the last commit of the PR.
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true
